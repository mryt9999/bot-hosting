const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const lotteryModel = require('../models/lotterySchema');
const lotteryCooldownModel = require('../models/lotteryCooldownSchema');
const dbUtils = require('../utils/dbUtils');

const LOTTERIES_CHANNEL_ID = process.env.LOTTERIES_CHANNEL_ID;
const LOTTERY_LOGS_CHANNEL_ID = process.env.LOTTERY_LOGS_CHANNEL_ID;

const NUMBER_LOTTERY_COST = 100;
const NUMBER_LOTTERY_MAX = 1000;
const NUMBER_LOTTERY_COOLDOWN = 24 * 60 * 60 * 1000; // 1 day

const RAFFLE_LOTTERY_COST = 1000;
const RAFFLE_LOTTERY_STARTING_POOL = 10000;
const RAFFLE_LOTTERY_DURATION = 24 * 60 * 60 * 1000; // 24 hours
const RAFFLE_LOTTERY_COOLDOWN = 4 * 60 * 60 * 1000; // 4 hours

const LOTTERY_ARCHIVAL_DELAY = 3 * 60 * 60 * 1000; // 3 hours in milliseconds

function createLotteryEmbed(lottery, ended = false) {
    const isNumber = lottery.type === 'number';
    const embed = new EmbedBuilder()
        .setColor(ended ? 0x95A5A6 : 0xF39C12)
        .setTimestamp();

    if (isNumber) {
        embed.setTitle('üé≤ Number Draw Lottery (1-1000)')
            .setDescription(
                ended
                    ? '**This lottery has ended.**'
                    : 'Guess the winning number! Buy draws to increase your chances.'
            )
            .addFields(
                { name: 'üí∞ Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                { name: 'üéØ Numbers Used', value: `${lottery.usedNumbers.length}/${NUMBER_LOTTERY_MAX}`, inline: true },
                { name: 'üí≥ Entry Cost', value: `${NUMBER_LOTTERY_COST} points per draw`, inline: true },
                { name: 'üé∞ How to Play', value: 'Click "Buy Draw" to get a random number. Check the thread below for all draws!', inline: false }
            );

        if (lottery.winnerId) {
            embed.addFields({
                name: 'üèÜ Winner',
                value: `<@${lottery.winnerId}> won with number **${lottery.participants.find(p => p.userId === lottery.winnerId)?.number}**!`,
                inline: false
            });
        }
    } else {
        embed.setTitle('üéüÔ∏è Raffle Lottery (24 Hour)')
            .setDescription(
                ended
                    ? '**This lottery has ended.**'
                    : 'Enter for a chance to win! One entry per person.'
            )
            .addFields(
                { name: 'üí∞ Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                { name: 'üë• Participants', value: `${lottery.participants.length}`, inline: true },
                { name: 'üí≥ Entry Cost', value: `${RAFFLE_LOTTERY_COST} points (one entry)`, inline: true }
            );

        if (!ended) {
            embed.addFields({
                name: '‚è∞ Ends',
                value: `<t:${Math.floor(lottery.endsAt / 1000)}:R>`,
                inline: false
            });
        }

        embed.addFields({
            name: 'üé∞ How to Play',
            value: 'Click "Enter Raffle" to participate. Check the thread below for all entries!',
            inline: false
        });

        if (lottery.winnerId) {
            embed.addFields({
                name: 'üèÜ Winner',
                value: `<@${lottery.winnerId}> won the raffle!`,
                inline: false
            });
        }
    }

    return embed;
}

function createLotteryButtons(lotteryId, type) {
    const button = new ButtonBuilder()
        .setCustomId(`lottery_${type}_${lotteryId}`)
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üé∞');

    if (type === 'number') {
        button.setLabel(`Buy Draw (${NUMBER_LOTTERY_COST} points)`);
    } else {
        button.setLabel(`Enter Raffle (${RAFFLE_LOTTERY_COST} points)`);
    }

    return new ActionRowBuilder().addComponents(button);
}

async function fetchAllThreadMessages(thread) {
    const allMessages = [];
    let lastId;

    while (true) {
        const options = { limit: 100 };
        if (lastId) {
            options.before = lastId;
        }

        const batch = await thread.messages.fetch(options);
        if (batch.size === 0) {
            break;
        }

        allMessages.push(...Array.from(batch.values()));
        lastId = batch.last().id;

        if (batch.size < 100) {
            break;
        }
    }

    return allMessages.sort((a, b) => a.createdTimestamp - b.createdTimestamp);
}

async function archiveLottery(lottery, client, winnerId, winningNumber) {
    try {
        const guild = client.guilds.cache.get(lottery.serverID);
        if (!guild) {
            console.error(`[Lottery] Guild not found for archival: ${lottery.serverID}`);
            return;
        }

        const lotteryChannel = guild.channels.cache.get(lottery.channelId);
        const logsChannel = guild.channels.cache.get(LOTTERY_LOGS_CHANNEL_ID);

        if (!logsChannel) {
            console.error('[Lottery] Lottery logs channel not found');
            return;
        }

        let sortedMessages = [];
        let threadName = '';

        // Fetch and archive thread messages if available
        if (lottery.logThreadId) {
            try {
                const thread = await client.channels.fetch(lottery.logThreadId);
                if (thread) {
                    sortedMessages = await fetchAllThreadMessages(thread);
                    threadName = thread.name;
                    console.log(`[Lottery] Fetched ${sortedMessages.length} messages from thread`);
                }
            } catch (threadError) {
                console.error('[Lottery] Failed to fetch thread messages:', threadError);
            }
        }

        // Create archive embed based on lottery type
        const isNumber = lottery.type === 'number';
        const archiveEmbed = new EmbedBuilder()
            .setTitle(isNumber ? 'üé≤ Number Draw Lottery - Archived' : 'üéüÔ∏è Raffle Lottery - Archived')
            .setColor(0x95A5A6)
            .setDescription('This lottery has ended and been archived.')
            .setTimestamp();

        if (isNumber) {
            archiveEmbed.addFields(
                { name: 'üí∞ Final Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                { name: 'üéØ Numbers Used', value: `${lottery.usedNumbers.length}/${NUMBER_LOTTERY_MAX}`, inline: true },
                { name: 'üèÜ Winner', value: winnerId ? `<@${winnerId}>` : 'None', inline: true },
                { name: 'üé≤ Winning Number', value: winningNumber ? `${winningNumber}` : 'N/A', inline: true },
                { name: 'üìÖ Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: true },
                { name: 'üèÅ Ended', value: `<t:${Math.floor((lottery.endedAt || Date.now()) / 1000)}:F>`, inline: true },
                { name: 'üìä Total Draws', value: `${Math.max(0, sortedMessages.length - 1)}`, inline: true },
                { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
            );
        } else {
            archiveEmbed.addFields(
                { name: 'üí∞ Final Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                { name: 'üë• Total Participants', value: `${lottery.participants.length}`, inline: true },
                { name: 'üèÜ Winner', value: winnerId ? `<@${winnerId}>` : 'None', inline: true },
                { name: 'üìÖ Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: true },
                { name: 'üèÅ Ended', value: `<t:${Math.floor((lottery.endedAt || Date.now()) / 1000)}:F>`, inline: true },
                { name: 'üìä Total Entries', value: `${Math.max(0, sortedMessages.length - 1)}`, inline: true },
                { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
            );
        }

        // Post archive embed
        const archiveMessage = await logsChannel.send({ embeds: [archiveEmbed] });

        // Create archive thread if we have messages to copy
        if (sortedMessages.length > 1) {
            try {
                const archiveThread = await archiveMessage.startThread({
                    name: threadName || `${isNumber ? 'üé≤ Draws' : 'üéüÔ∏è Entries'} History - ${lottery._id.toString().slice(-6)}`,
                    autoArchiveDuration: 10080, // 7 days
                    reason: 'Archived lottery history'
                });

                // Copy messages (skip first message which is the initial thread message)
                for (const msg of sortedMessages.slice(1)) {
                    if (msg.embeds.length > 0) {
                        await archiveThread.send({
                            content: msg.content || undefined,
                            embeds: msg.embeds
                        });
                    } else if (msg.content) {
                        await archiveThread.send({ content: msg.content });
                    }

                    // Rate limit protection
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                console.log(`[Lottery] Archived thread history for lottery: ${lottery._id}`);
            } catch (threadError) {
                console.error('[Lottery] Failed to create/populate archive thread:', threadError);
            }
        }

        // Delete original message from lotteries channel
        if (lotteryChannel && lottery.messageId) {
            try {
                const message = await lotteryChannel.messages.fetch(lottery.messageId);
                await message.delete();
                console.log(`[Lottery] Deleted original lottery message: ${lottery._id}`);
            } catch (deleteError) {
                console.error('[Lottery] Failed to delete original message:', deleteError);
            }
        }

        // Mark as archived in database
        lottery.archived = true;
        if (!lottery.endedAt) {
            lottery.endedAt = Date.now();
        }
        await lottery.save();

        console.log(`[Lottery] Successfully archived lottery: ${lottery._id}`);
    } catch (error) {
        console.error('[Lottery] Error in archiveLottery:', error);
    }
}

async function createNumberLottery(client, guildId) {
    const cooldown = await lotteryCooldownModel.findOne({
        serverID: guildId,
        type: 'number'
    });

    if (cooldown && Date.now() < cooldown.nextAvailableAt) {
        return null;
    }

    const existingLottery = await lotteryModel.findOne({
        serverID: guildId,
        type: 'number',
        status: 'active'
    });

    if (existingLottery) {
        return null;
    }

    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
        return null;
    }

    const lotteryData = {
        serverID: guildId,
        type: 'number',
        status: 'active',
        prizePool: 0,
        startedAt: Date.now(),
        channelId: LOTTERIES_CHANNEL_ID,
        winningNumber: Math.floor(Math.random() * NUMBER_LOTTERY_MAX) + 1,
        usedNumbers: [],
        participants: []
    };

    const lottery = await lotteryModel.create(lotteryData);

    const channel = guild.channels.cache.get(LOTTERIES_CHANNEL_ID);
    if (channel) {
        const embed = createLotteryEmbed(lottery);
        const buttons = createLotteryButtons(lottery._id, 'number');

        const message = await channel.send({ embeds: [embed], components: [buttons] });

        lottery.messageId = message.id;

        try {
            const thread = await message.startThread({
                name: `üé≤ Draws - ${lottery._id.toString().slice(-6)}`,
                autoArchiveDuration: 1440,
                reason: 'Number Draw Lottery thread'
            });

            lottery.logThreadId = thread.id;

            const initialEmbed = new EmbedBuilder()
                .setTitle('üé≤ Number Draw Lottery')
                .setColor(0xF39C12)
                .setDescription('All draws for this lottery will be logged here.')
                .addFields(
                    { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: true },
                    { name: 'Entry Cost', value: `${NUMBER_LOTTERY_COST} points per draw`, inline: true },
                    { name: 'Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: false }
                )
                .setTimestamp();

            await thread.send({ embeds: [initialEmbed] });
        } catch (error) {
            console.error('Failed to create lottery thread:', error);
        }

        await lottery.save();
        console.log(`[Lottery] Created Number Draw lottery: ${lottery._id}`);
    }

    return lottery;
}

async function createRaffleLottery(client, guildId) {
    const cooldown = await lotteryCooldownModel.findOne({
        serverID: guildId,
        type: 'raffle'
    });

    if (cooldown && Date.now() < cooldown.nextAvailableAt) {
        return null;
    }

    const existingLottery = await lotteryModel.findOne({
        serverID: guildId,
        type: 'raffle',
        status: 'active'
    });

    if (existingLottery) {
        return null;
    }

    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
        return null;
    }

    const lotteryData = {
        serverID: guildId,
        type: 'raffle',
        status: 'active',
        prizePool: RAFFLE_LOTTERY_STARTING_POOL,
        startedAt: Date.now(),
        endsAt: Date.now() + RAFFLE_LOTTERY_DURATION,
        channelId: LOTTERIES_CHANNEL_ID,
        participants: []
    };

    const lottery = await lotteryModel.create(lotteryData);

    const channel = guild.channels.cache.get(LOTTERIES_CHANNEL_ID);
    if (channel) {
        const embed = createLotteryEmbed(lottery);
        const buttons = createLotteryButtons(lottery._id, 'raffle');

        const message = await channel.send({ embeds: [embed], components: [buttons] });

        lottery.messageId = message.id;

        try {
            const thread = await message.startThread({
                name: `üéüÔ∏è Entries - ${lottery._id.toString().slice(-6)}`,
                autoArchiveDuration: 1440,
                reason: 'Raffle Lottery thread'
            });

            lottery.logThreadId = thread.id;

            const initialEmbed = new EmbedBuilder()
                .setTitle('üéüÔ∏è Raffle Lottery')
                .setColor(0xF39C12)
                .setDescription('All entries for this raffle will be logged here.')
                .addFields(
                    { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: true },
                    { name: 'Entry Cost', value: `${RAFFLE_LOTTERY_COST} points`, inline: true },
                    { name: 'Starting Pool', value: `${RAFFLE_LOTTERY_STARTING_POOL.toLocaleString()} points`, inline: true },
                    { name: 'Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: true },
                    { name: 'Ends', value: `<t:${Math.floor(lottery.endsAt / 1000)}:R>`, inline: true }
                )
                .setTimestamp();

            await thread.send({ embeds: [initialEmbed] });
        } catch (error) {
            console.error('Failed to create lottery thread:', error);
        }

        await lottery.save();

        scheduleRaffleEnd(lottery._id, lottery.endsAt, client);

        console.log(`[Lottery] Created Raffle lottery: ${lottery._id}`);
    }

    return lottery;
}

async function endNumberLottery(lottery, client, guild, winnerId, winningNumber) {
    lottery.status = 'ended';
    lottery.winnerId = winnerId;
    lottery.endedAt = Date.now();
    await lottery.save();

    const winnerProfile = await dbUtils.ensureProfile(winnerId, guild.id);
    winnerProfile.balance += lottery.prizePool;
    await winnerProfile.save();

    try {
        const balanceChangeEvent = require('../events/balanceChange');
        const member = await guild.members.fetch(winnerId);
        balanceChangeEvent.execute(member);
    } catch (err) {
        console.error('Failed to trigger balance change event:', err);
    }

    const channel = guild.channels.cache.get(lottery.channelId);
    if (channel && lottery.messageId) {
        try {
            const message = await channel.messages.fetch(lottery.messageId);
            const embed = createLotteryEmbed(lottery, true);
            await message.edit({ embeds: [embed], components: [] });
        } catch (error) {
            console.error('Failed to update lottery message:', error);
        }
    }

    if (lottery.logThreadId) {
        try {
            const thread = await client.channels.fetch(lottery.logThreadId);
            if (thread) {
                const logEmbed = new EmbedBuilder()
                    .setTitle('üéâ Number Draw Lottery Winner!')
                    .setColor(0x2ECC71)
                    .addFields(
                        { name: 'Winner', value: `<@${winnerId}>`, inline: true },
                        { name: 'Winning Number', value: `${winningNumber}`, inline: true },
                        { name: 'Prize Won', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                        { name: 'Total Draws', value: `${lottery.usedNumbers.length}`, inline: true },
                        { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
                    )
                    .setTimestamp();

                await thread.send({
                    content: `<@${winnerId}> üéâ **CONGRATULATIONS! YOU WON!**`,
                    embeds: [logEmbed]
                });

                setTimeout(async () => {
                    try {
                        await thread.setArchived(true);
                    } catch (error) {
                        console.error('Failed to archive thread:', error);
                    }
                }, 5000);
            }
        } catch (error) {
            console.error('Failed to send winner message to thread:', error);
        }
    }

    setTimeout(() => archiveLottery(lottery, client, winnerId, winningNumber), LOTTERY_ARCHIVAL_DELAY);

    await lotteryCooldownModel.findOneAndUpdate(
        { serverID: guild.id, type: 'number' },
        { nextAvailableAt: Date.now() + NUMBER_LOTTERY_COOLDOWN },
        { upsert: true }
    );

    setTimeout(async () => {
        try {
            await lotteryModel.findByIdAndDelete(lottery._id);
            console.log(`[Lottery] Deleted completed Number Draw lottery from database: ${lottery._id}`);
        } catch (error) {
            console.error('Failed to delete completed lottery:', error);
        }
    }, 65 * 60 * 1000);

    setTimeout(async () => {
        await createNumberLottery(client, guild.id);
    }, NUMBER_LOTTERY_COOLDOWN);
}

async function endRaffleLottery(lottery, client, guild) {
    if (lottery.participants.length === 0) {
        lottery.status = 'ended';
        lottery.endedAt = Date.now();
        await lottery.save();

        const channel = guild.channels.cache.get(lottery.channelId);
        if (channel && lottery.messageId) {
            try {
                const message = await channel.messages.fetch(lottery.messageId);
                const embed = new EmbedBuilder()
                    .setTitle('üéüÔ∏è Raffle Lottery Ended')
                    .setDescription('No participants. Lottery cancelled.')
                    .setColor(0x95A5A6)
                    .setTimestamp();
                await message.edit({ embeds: [embed], components: [] });
            } catch (error) {
                console.error('Failed to update lottery message:', error);
            }
        }

        if (lottery.logThreadId) {
            try {
                const thread = await client.channels.fetch(lottery.logThreadId);
                if (thread) {
                    const cancelEmbed = new EmbedBuilder()
                        .setTitle('‚ùå Raffle Cancelled')
                        .setDescription('No participants joined this raffle.')
                        .setColor(0x95A5A6)
                        .setTimestamp();

                    await thread.send({ embeds: [cancelEmbed] });

                    setTimeout(async () => {
                        try {
                            await thread.setArchived(true);
                        } catch (error) {
                            console.error('Failed to archive thread:', error);
                        }
                    }, 5000);
                }
            } catch (error) {
                console.error('Failed to send cancellation to thread:', error);
            }
        }

        setTimeout(() => archiveLottery(lottery, client, null, null), LOTTERY_ARCHIVAL_DELAY);

        await lotteryCooldownModel.findOneAndUpdate(
            { serverID: guild.id, type: 'raffle' },
            { nextAvailableAt: Date.now() + RAFFLE_LOTTERY_COOLDOWN },
            { upsert: true }
        );

        setTimeout(async () => {
            try {
                await lotteryModel.findByIdAndDelete(lottery._id);
                console.log(`[Lottery] Deleted cancelled Raffle lottery from database: ${lottery._id}`);
            } catch (error) {
                console.error('Failed to delete completed lottery:', error);
            }
        }, 65 * 60 * 1000);

        setTimeout(async () => {
            await createRaffleLottery(client, guild.id);
        }, RAFFLE_LOTTERY_COOLDOWN);

        return;
    }

    const randomIndex = Math.floor(Math.random() * lottery.participants.length);
    const winner = lottery.participants[randomIndex];

    lottery.status = 'ended';
    lottery.winnerId = winner.userId;
    lottery.endedAt = Date.now();
    await lottery.save();

    const winnerProfile = await dbUtils.ensureProfile(winner.userId, guild.id);
    winnerProfile.balance += lottery.prizePool;
    await winnerProfile.save();

    try {
        const balanceChangeEvent = require('../events/balanceChange');
        const member = await guild.members.fetch(winner.userId);
        balanceChangeEvent.execute(member);
    } catch (err) {
        console.error('Failed to trigger balance change event:', err);
    }

    const channel = guild.channels.cache.get(lottery.channelId);
    if (channel && lottery.messageId) {
        try {
            const message = await channel.messages.fetch(lottery.messageId);
            const embed = createLotteryEmbed(lottery, true);
            await message.edit({ embeds: [embed], components: [] });
        } catch (error) {
            console.error('Failed to update lottery message:', error);
        }
    }

    if (lottery.logThreadId) {
        try {
            const thread = await client.channels.fetch(lottery.logThreadId);
            if (thread) {
                const logEmbed = new EmbedBuilder()
                    .setTitle('üéâ Raffle Lottery Winner!')
                    .setColor(0x2ECC71)
                    .addFields(
                        { name: 'Winner', value: `<@${winner.userId}>`, inline: true },
                        { name: 'Prize Won', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                        { name: 'Total Participants', value: `${lottery.participants.length}`, inline: true },
                        { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
                    )
                    .setTimestamp();

                await thread.send({
                    content: `<@${winner.userId}> üéâ **CONGRATULATIONS! YOU WON THE RAFFLE!**`,
                    embeds: [logEmbed]
                });

                setTimeout(async () => {
                    try {
                        await thread.setArchived(true);
                    } catch (error) {
                        console.error('Failed to archive thread:', error);
                    }
                }, 5000);
            }
        } catch (error) {
            console.error('Failed to send winner message to thread:', error);
        }
    }

    setTimeout(() => archiveLottery(lottery, client, winner.userId, null), 60 * 60 * 1000);

    await lotteryCooldownModel.findOneAndUpdate(
        { serverID: guild.id, type: 'raffle' },
        { nextAvailableAt: Date.now() + RAFFLE_LOTTERY_COOLDOWN },
        { upsert: true }
    );

    setTimeout(async () => {
        try {
            await lotteryModel.findByIdAndDelete(lottery._id);
            console.log(`[Lottery] Deleted completed Raffle lottery from database: ${lottery._id}`);
        } catch (error) {
            console.error('Failed to delete completed lottery:', error);
        }
    }, 65 * 60 * 1000);

    setTimeout(async () => {
        await createRaffleLottery(client, guild.id);
    }, RAFFLE_LOTTERY_COOLDOWN);
}

function scheduleRaffleEnd(lotteryId, endsAt, client) {
    const timeUntilEnd = endsAt - Date.now();

    if (timeUntilEnd <= 0) {
        return;
    }

    setTimeout(async () => {
        try {
            const lottery = await lotteryModel.findById(lotteryId);
            if (!lottery || lottery.status === 'ended') {
                return;
            }

            const guild = client.guilds.cache.get(lottery.serverID);
            if (!guild) {
                return;
            }

            await endRaffleLottery(lottery, client, guild);
        } catch (error) {
            console.error('Error ending raffle lottery:', error);
        }
    }, timeUntilEnd);
}

module.exports = {
    createLotteryEmbed,
    createLotteryButtons,
    endNumberLottery,
    endRaffleLottery,
    scheduleRaffleEnd,
    createNumberLottery,
    createRaffleLottery,
    archiveLottery,
    NUMBER_LOTTERY_COST,
    RAFFLE_LOTTERY_COST
};