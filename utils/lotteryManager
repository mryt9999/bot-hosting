const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const lotteryModel = require('../models/lotterySchema');
const lotteryCooldownModel = require('../models/lotteryCooldownSchema');
const dbUtils = require('../utils/dbUtils');

const LOTTERIES_CHANNEL_ID = process.env.LOTTERIES_CHANNEL_ID;
const LOTTERY_LOGS_CHANNEL_ID = process.env.LOTTERY_LOGS_CHANNEL_ID;

const NUMBER_LOTTERY_COST = 100;
const NUMBER_LOTTERY_MAX = 1000;
const NUMBER_LOTTERY_COOLDOWN = 4 * 60 * 60 * 1000; // 4 hours

const RAFFLE_LOTTERY_COST = 1000;
const RAFFLE_LOTTERY_STARTING_POOL = 10000;
const RAFFLE_LOTTERY_DURATION = 24 * 60 * 60 * 1000; // 24 hours
const RAFFLE_LOTTERY_COOLDOWN = 8 * 60 * 60 * 1000; // 8 hours

const ANIMAL_LOTTERY_COST = 500;
const ANIMAL_LOTTERY_STARTING_POOL = 5000;
const ANIMAL_LOTTERY_DURATION = 24 * 60 * 60 * 1000; // 24 hours
const ANIMAL_LOTTERY_COOLDOWN = 24 * 60 * 60 * 1000; // 24 hours
const ANIMAL_LOTTERY_ANIMALS = ['üêé', 'üê¢', 'üêá', 'ü¶ò', 'ü¶é', 'üê∂', 'üê±', 'ü¶Ö', 'ü¶Å'];

const LOTTERY_ARCHIVAL_DELAY = 3 * 60 * 60 * 1000; // 3 hours

function createLotteryEmbed(lottery, ended = false) {
    const isNumber = lottery.type === 'number';
    const isRaffle = lottery.type === 'raffle';
    const isAnimal = lottery.type === 'animal';

    const embed = new EmbedBuilder()
        .setColor(ended ? 0x95A5A6 : 0xF39C12)
        .setTimestamp();

    if (isNumber) {
        embed.setTitle('üé≤ Number Draw Lottery (1-1000)')
            .setDescription(
                ended
                    ? '**This lottery has ended.**'
                    : 'Guess the winning number! Buy draws to increase your chances.'
            )
            .addFields(
                { name: 'üí∞ Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                { name: 'üéØ Numbers Used', value: `${lottery.usedNumbers.length}/${NUMBER_LOTTERY_MAX}`, inline: true },
                { name: 'üí≥ Entry Cost', value: `${NUMBER_LOTTERY_COST} points per draw`, inline: true },
                { name: 'üé∞ How to Play', value: 'Click "Buy Draw" to get a random number. Check the thread below for all draws!', inline: false }
            );

        if (lottery.winnerId) {
            embed.addFields({
                name: 'üèÜ Winner',
                value: `<@${lottery.winnerId}> won with number **${lottery.participants.find(p => p.userId === lottery.winnerId)?.number}**!`,
                inline: false
            });
        }
    } else if (isRaffle) {
        embed.setTitle('üéüÔ∏è Raffle Lottery (24 Hour)')
            .setDescription(
                ended
                    ? '**This lottery has ended.**'
                    : 'Enter for a chance to win! One entry per person.'
            )
            .addFields(
                { name: 'üí∞ Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                { name: 'üë• Participants', value: `${lottery.participants.length}`, inline: true },
                { name: 'üí≥ Entry Cost', value: `${RAFFLE_LOTTERY_COST} points (one entry)`, inline: true }
            );

        if (!ended) {
            embed.addFields({
                name: '‚è∞ Ends',
                value: `<t:${Math.floor(lottery.endsAt / 1000)}:R>`,
                inline: false
            });
        }

        embed.addFields({
            name: 'üé∞ How to Play',
            value: 'Click "Enter Raffle" to participate. Check the thread below for all entries!',
            inline: false
        });

        if (lottery.winnerId) {
            embed.addFields({
                name: 'üèÜ Winner',
                value: `<@${lottery.winnerId}> won the raffle!`,
                inline: false
            });
        }
    } else if (isAnimal) {
        embed.setTitle('üèá Animal Race Lottery (24 Hour)')
            .setDescription(
                ended
                    ? '**This race has ended.**'
                    : 'Pick your champion! One bet per person. Winners share the prize pool!'
            );

        // ‚úÖ Use lottery's own availableAnimals instead of global constant
        if (!ended && lottery.availableAnimals && lottery.availableAnimals.length > 0) {
            const animalStats = lottery.availableAnimals.map(animal => {
                const count = lottery.participants.filter(p => p.animal === animal).length;
                return `${animal} √ó ${count}`;
            }).join(' | ');

            embed.addFields(
                { name: 'üèÅ Racing Animals', value: animalStats, inline: false }
            );
        }

        embed.addFields(
            { name: 'üí∞ Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
            { name: 'üë• Participants', value: `${lottery.participants.length}`, inline: true },
            { name: 'üí≥ Entry Cost', value: `${ANIMAL_LOTTERY_COST} points (one bet)`, inline: true }
        );

        if (!ended) {
            embed.addFields({
                name: '‚è∞ Race Ends',
                value: `<t:${Math.floor(lottery.endsAt / 1000)}:R>`,
                inline: false
            });
        }

        embed.addFields({
            name: 'üé∞ How to Play',
            value: 'Click "Pick Animal" to choose your champion! Check the thread for all bets.',
            inline: false
        });

        if (ended && lottery.winningAnimal) {
            const winnerCount = lottery.winnerIds ? lottery.winnerIds.length : 0;
            const prizePerWinner = winnerCount > 0 ? Math.floor(lottery.prizePool / winnerCount) : 0;

            let winnerText = `${lottery.winningAnimal} **WON THE RACE!**\n\n`;

            if (winnerCount === 0) {
                winnerText += 'üíî No one bet on the winner! Prize pool lost.';
            } else if (winnerCount === 1) {
                winnerText += `üèÜ Winner: <@${lottery.winnerIds[0]}>\nüí∞ Prize: ${prizePerWinner.toLocaleString()} points`;
            } else {
                winnerText += `üèÜ ${winnerCount} Winners!\nüí∞ Each won: ${prizePerWinner.toLocaleString()} points\n\n`;
                winnerText += lottery.winnerIds.map(id => `<@${id}>`).join(', ');
            }

            embed.addFields({
                name: 'üèÅ Race Results',
                value: winnerText,
                inline: false
            });
        }
    }

    return embed;
}

function createLotteryButtons(lotteryId, type) {
    const button = new ButtonBuilder()
        .setCustomId(`lottery_${type}_${lotteryId}`)
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üé∞');

    if (type === 'number') {
        button.setLabel(`Buy Draw (${NUMBER_LOTTERY_COST} points)`);
    } else if (type === 'raffle') {
        button.setLabel(`Enter Raffle (${RAFFLE_LOTTERY_COST} points)`);
    } else if (type === 'animal') {
        button.setLabel(`Pick Animal (${ANIMAL_LOTTERY_COST} points)`);
        button.setEmoji('üèá');
    }

    return new ActionRowBuilder().addComponents(button);
}

async function fetchAllThreadMessages(thread) {
    const allMessages = [];
    let lastId;

    while (true) {
        const options = { limit: 100 };
        if (lastId) {
            options.before = lastId;
        }

        const batch = await thread.messages.fetch(options);
        if (batch.size === 0) {
            break;
        }

        allMessages.push(...Array.from(batch.values()));
        lastId = batch.last().id;

        if (batch.size < 100) {
            break;
        }
    }

    return allMessages.sort((a, b) => a.createdTimestamp - b.createdTimestamp);
}

async function archiveLottery(lottery, client, winnerId, winningNumber) {
    try {
        const guild = client.guilds.cache.get(lottery.serverID);
        if (!guild) {
            console.error(`[Lottery] Guild not found for archival: ${lottery.serverID}`);
            return;
        }

        const lotteryChannel = guild.channels.cache.get(lottery.channelId);
        const logsChannel = guild.channels.cache.get(LOTTERY_LOGS_CHANNEL_ID);

        if (!logsChannel) {
            console.error('[Lottery] Lottery logs channel not found');
            return;
        }

        let sortedMessages = [];
        let threadName = '';

        if (lottery.logThreadId) {
            try {
                const thread = await client.channels.fetch(lottery.logThreadId);
                if (thread) {
                    sortedMessages = await fetchAllThreadMessages(thread);
                    threadName = thread.name;
                    console.log(`[Lottery] Fetched ${sortedMessages.length} messages from thread`);
                }
            } catch (threadError) {
                console.error('[Lottery] Failed to fetch thread messages:', threadError);
            }
        }

        const isNumber = lottery.type === 'number';
        const isRaffle = lottery.type === 'raffle';
        const isAnimal = lottery.type === 'animal';

        const archiveEmbed = new EmbedBuilder()
            .setColor(0x95A5A6)
            .setDescription('This lottery has ended and been archived.')
            .setTimestamp();

        if (isNumber) {
            archiveEmbed.setTitle('üé≤ Number Draw Lottery - Archived')
                .addFields(
                    { name: 'üí∞ Final Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                    { name: 'üéØ Numbers Used', value: `${lottery.usedNumbers.length}/${NUMBER_LOTTERY_MAX}`, inline: true },
                    { name: 'üèÜ Winner', value: winnerId ? `<@${winnerId}>` : 'None', inline: true },
                    { name: 'üé≤ Winning Number', value: winningNumber ? `${winningNumber}` : 'N/A', inline: true },
                    { name: 'üìÖ Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: true },
                    { name: 'üèÅ Ended', value: `<t:${Math.floor((lottery.endedAt || Date.now()) / 1000)}:F>`, inline: true },
                    { name: 'üìä Total Draws', value: `${Math.max(0, sortedMessages.length - 1)}`, inline: true },
                    { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
                );
        } else if (isRaffle) {
            archiveEmbed.setTitle('üéüÔ∏è Raffle Lottery - Archived')
                .addFields(
                    { name: 'üí∞ Final Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                    { name: 'üë• Total Participants', value: `${lottery.participants.length}`, inline: true },
                    { name: 'üèÜ Winner', value: winnerId ? `<@${winnerId}>` : 'None', inline: true },
                    { name: 'üìÖ Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: true },
                    { name: 'üèÅ Ended', value: `<t:${Math.floor((lottery.endedAt || Date.now()) / 1000)}:F>`, inline: true },
                    { name: 'üìä Total Entries', value: `${Math.max(0, sortedMessages.length - 1)}`, inline: true },
                    { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
                );
        } else if (isAnimal) {
            const winnerCount = lottery.winnerIds ? lottery.winnerIds.length : 0;
            archiveEmbed.setTitle('üèá Animal Race Lottery - Archived')
                .addFields(
                    { name: 'üí∞ Final Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                    { name: 'üë• Total Bets', value: `${lottery.participants.length}`, inline: true },
                    { name: 'üèÜ Winners', value: winnerCount > 0 ? `${winnerCount}` : 'None', inline: true },
                    { name: 'üèÅ Winning Animal', value: lottery.winningAnimal || 'N/A', inline: true },
                    { name: 'üíé Prize Per Winner', value: winnerCount > 0 ? `${Math.floor(lottery.prizePool / winnerCount).toLocaleString()} points` : 'N/A', inline: true },
                    { name: 'üìÖ Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: true },
                    { name: 'üèÅ Ended', value: `<t:${Math.floor((lottery.endedAt || Date.now()) / 1000)}:F>`, inline: true },
                    { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
                );
        }

        const archiveMessage = await logsChannel.send({ embeds: [archiveEmbed] });

        if (sortedMessages.length > 1) {
            try {
                const archiveThread = await archiveMessage.startThread({
                    name: threadName || `Archive - ${lottery.type} - ${lottery._id.toString().slice(-6)}`,
                    autoArchiveDuration: 10080,
                    reason: 'Archived lottery history'
                });

                for (const msg of sortedMessages.slice(1)) {
                    if (msg.embeds.length > 0) {
                        await archiveThread.send({
                            content: msg.content || undefined,
                            embeds: msg.embeds
                        });
                    } else if (msg.content) {
                        await archiveThread.send({ content: msg.content });
                    }

                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                console.log(`[Lottery] Archived thread history for lottery: ${lottery._id}`);
            } catch (threadError) {
                console.error('[Lottery] Failed to create/populate archive thread:', threadError);
            }
        }

        if (lotteryChannel && lottery.messageId) {
            try {
                const message = await lotteryChannel.messages.fetch(lottery.messageId);
                await message.delete();
                console.log(`[Lottery] Deleted original lottery message: ${lottery._id}`);
            } catch (deleteError) {
                console.error('[Lottery] Failed to delete original message:', deleteError);
            }
        }

        lottery.archived = true;
        if (!lottery.endedAt) {
            lottery.endedAt = Date.now();
        }
        await lottery.save();

        console.log(`[Lottery] Successfully archived lottery: ${lottery._id}`);
    } catch (error) {
        console.error('[Lottery] Error in archiveLottery:', error);
    }
}

async function createNumberLottery(client, guildId) {
    const cooldown = await lotteryCooldownModel.findOne({
        serverID: guildId,
        type: 'number'
    });

    if (cooldown && Date.now() < cooldown.nextAvailableAt) {
        return null;
    }

    const existingLottery = await lotteryModel.findOne({
        serverID: guildId,
        type: 'number',
        status: 'active'
    });

    if (existingLottery) {
        return null;
    }

    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
        return null;
    }

    const lotteryData = {
        serverID: guildId,
        type: 'number',
        status: 'active',
        prizePool: 0,
        startedAt: Date.now(),
        channelId: LOTTERIES_CHANNEL_ID,
        winningNumber: Math.floor(Math.random() * NUMBER_LOTTERY_MAX) + 1,
        usedNumbers: [],
        participants: []
    };

    const lottery = await lotteryModel.create(lotteryData);

    const channel = guild.channels.cache.get(LOTTERIES_CHANNEL_ID);
    if (channel) {
        const embed = createLotteryEmbed(lottery);
        const buttons = createLotteryButtons(lottery._id, 'number');

        const message = await channel.send({ embeds: [embed], components: [buttons] });

        lottery.messageId = message.id;

        try {
            const thread = await message.startThread({
                name: `üé≤ Draws - ${lottery._id.toString().slice(-6)}`,
                autoArchiveDuration: 1440,
                reason: 'Number Draw Lottery thread'
            });

            lottery.logThreadId = thread.id;

            const initialEmbed = new EmbedBuilder()
                .setTitle('üé≤ Number Draw Lottery')
                .setColor(0xF39C12)
                .setDescription('All draws for this lottery will be logged here.')
                .addFields(
                    { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: true },
                    { name: 'Entry Cost', value: `${NUMBER_LOTTERY_COST} points per draw`, inline: true },
                    { name: 'Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: false }
                )
                .setTimestamp();

            await thread.send({ embeds: [initialEmbed] });
        } catch (error) {
            console.error('Failed to create lottery thread:', error);
        }

        await lottery.save();
        console.log(`[Lottery] Created Number Draw lottery: ${lottery._id}`);
    }

    return lottery;
}

async function createRaffleLottery(client, guildId) {
    const cooldown = await lotteryCooldownModel.findOne({
        serverID: guildId,
        type: 'raffle'
    });

    if (cooldown && Date.now() < cooldown.nextAvailableAt) {
        return null;
    }

    const existingLottery = await lotteryModel.findOne({
        serverID: guildId,
        type: 'raffle',
        status: 'active'
    });

    if (existingLottery) {
        return null;
    }

    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
        return null;
    }

    const lotteryData = {
        serverID: guildId,
        type: 'raffle',
        status: 'active',
        prizePool: RAFFLE_LOTTERY_STARTING_POOL,
        startedAt: Date.now(),
        endsAt: Date.now() + RAFFLE_LOTTERY_DURATION,
        channelId: LOTTERIES_CHANNEL_ID,
        participants: []
    };

    const lottery = await lotteryModel.create(lotteryData);

    const channel = guild.channels.cache.get(LOTTERIES_CHANNEL_ID);
    if (channel) {
        const embed = createLotteryEmbed(lottery);
        const buttons = createLotteryButtons(lottery._id, 'raffle');

        const message = await channel.send({ embeds: [embed], components: [buttons] });

        lottery.messageId = message.id;

        try {
            const thread = await message.startThread({
                name: `üéüÔ∏è Entries - ${lottery._id.toString().slice(-6)}`,
                autoArchiveDuration: 1440,
                reason: 'Raffle Lottery thread'
            });

            lottery.logThreadId = thread.id;

            const initialEmbed = new EmbedBuilder()
                .setTitle('üéüÔ∏è Raffle Lottery')
                .setColor(0xF39C12)
                .setDescription('All entries for this raffle will be logged here.')
                .addFields(
                    { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: true },
                    { name: 'Entry Cost', value: `${RAFFLE_LOTTERY_COST} points`, inline: true },
                    { name: 'Starting Pool', value: `${RAFFLE_LOTTERY_STARTING_POOL.toLocaleString()} points`, inline: true },
                    { name: 'Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: true },
                    { name: 'Ends', value: `<t:${Math.floor(lottery.endsAt / 1000)}:R>`, inline: true }
                )
                .setTimestamp();

            await thread.send({ embeds: [initialEmbed] });
        } catch (error) {
            console.error('Failed to create lottery thread:', error);
        }

        await lottery.save();

        scheduleRaffleEnd(lottery._id, lottery.endsAt, client);

        console.log(`[Lottery] Created Raffle lottery: ${lottery._id}`);
    }

    return lottery;
}

async function createAnimalLottery(client, guildId) {
    const cooldown = await lotteryCooldownModel.findOne({
        serverID: guildId,
        type: 'animal'
    });

    if (cooldown && Date.now() < cooldown.nextAvailableAt) {
        return null;
    }

    const existingLottery = await lotteryModel.findOne({
        serverID: guildId,
        type: 'animal',
        status: 'active'
    });

    if (existingLottery) {
        return null;
    }

    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
        return null;
    }

    const winningAnimal = ANIMAL_LOTTERY_ANIMALS[Math.floor(Math.random() * ANIMAL_LOTTERY_ANIMALS.length)];

    const lotteryData = {
        serverID: guildId,
        type: 'animal',
        status: 'active',
        prizePool: ANIMAL_LOTTERY_STARTING_POOL,
        startedAt: Date.now(),
        endsAt: Date.now() + ANIMAL_LOTTERY_DURATION,
        channelId: LOTTERIES_CHANNEL_ID,
        winningAnimal: winningAnimal,
        availableAnimals: [...ANIMAL_LOTTERY_ANIMALS],
        participants: [],
        winnerIds: []
    };

    const lottery = await lotteryModel.create(lotteryData);

    const channel = guild.channels.cache.get(LOTTERIES_CHANNEL_ID);
    if (channel) {
        const embed = createLotteryEmbed(lottery);
        const buttons = createLotteryButtons(lottery._id, 'animal');

        const message = await channel.send({ embeds: [embed], components: [buttons] });

        lottery.messageId = message.id;

        try {
            const thread = await message.startThread({
                name: `üèá Race Bets - ${lottery._id.toString().slice(-6)}`,
                autoArchiveDuration: 1440,
                reason: 'Animal Race Lottery thread'
            });

            lottery.logThreadId = thread.id;

            const initialEmbed = new EmbedBuilder()
                .setTitle('üèá Animal Race Lottery')
                .setColor(0xF39C12)
                .setDescription('All bets for this race will be logged here. May the best animal win!')
                .addFields(
                    { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: true },
                    { name: 'Entry Cost', value: `${ANIMAL_LOTTERY_COST} points`, inline: true },
                    { name: 'Starting Pool', value: `${ANIMAL_LOTTERY_STARTING_POOL.toLocaleString()} points`, inline: true },
                    { name: 'Racing Animals', value: ANIMAL_LOTTERY_ANIMALS.join(' '), inline: false },
                    { name: 'Started', value: `<t:${Math.floor(lottery.startedAt / 1000)}:F>`, inline: true },
                    { name: 'Race Starts', value: `<t:${Math.floor(lottery.endsAt / 1000)}:R>`, inline: true }
                )
                .setTimestamp();

            await thread.send({ embeds: [initialEmbed] });
        } catch (error) {
            console.error('Failed to create lottery thread:', error);
        }

        await lottery.save();

        scheduleAnimalRaceEnd(lottery._id, lottery.endsAt, client);

        console.log(`[Lottery] Created Animal Race lottery: ${lottery._id} (Winner: ${winningAnimal})`);
    }

    return lottery;
}

async function endAnimalLottery(lottery, client, guild) {
    const winners = lottery.participants.filter(p => p.animal === lottery.winningAnimal);

    lottery.status = 'ended';
    lottery.endedAt = Date.now();
    lottery.winnerIds = winners.map(w => w.userId);
    await lottery.save();

    if (winners.length > 0) {
        const prizePerWinner = Math.floor(lottery.prizePool / winners.length);

        for (const winner of winners) {
            const winnerProfile = await dbUtils.ensureProfile(winner.userId, guild.id);
            winnerProfile.balance += prizePerWinner;
            await winnerProfile.save();

            try {
                const balanceChangeEvent = require('../events/balanceChange');
                const member = await guild.members.fetch(winner.userId);
                balanceChangeEvent.execute(member);
            } catch (err) {
                console.error('Failed to trigger balance change event:', err);
            }
        }
    }

    const channel = guild.channels.cache.get(lottery.channelId);
    if (channel && lottery.messageId) {
        try {
            const message = await channel.messages.fetch(lottery.messageId);
            const embed = createLotteryEmbed(lottery, true);
            await message.edit({ embeds: [embed], components: [] });
        } catch (error) {
            console.error('Failed to update lottery message:', error);
        }
    }

    if (lottery.logThreadId) {
        try {
            const thread = await client.channels.fetch(lottery.logThreadId);
            if (thread) {
                const winnerCount = winners.length;
                const prizePerWinner = winnerCount > 0 ? Math.floor(lottery.prizePool / winnerCount) : 0;

                let resultDescription = `**${lottery.winningAnimal} WON THE RACE!**\n\n`;

                if (winnerCount === 0) {
                    resultDescription += 'üíî No one bet on the winner!\nThe prize pool is lost to the void.';
                } else if (winnerCount === 1) {
                    resultDescription += `üèÜ **Solo Victory!**\n<@${winners[0].userId}> takes home the entire ${lottery.prizePool.toLocaleString()} points!`;
                } else {
                    resultDescription += `üèÜ **${winnerCount} Winners!**\n`;
                    resultDescription += `Each winner receives ${prizePerWinner.toLocaleString()} points!\n\n`;
                    resultDescription += winners.map(w => `‚Ä¢ <@${w.userId}>`).join('\n');
                }

                const resultEmbed = new EmbedBuilder()
                    .setTitle('üèÅ Race Results!')
                    .setColor(winnerCount > 0 ? 0x2ECC71 : 0xE74C3C)
                    .setDescription(resultDescription)
                    .addFields(
                        { name: 'Winning Animal', value: lottery.winningAnimal, inline: true },
                        { name: 'Total Prize Pool', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                        { name: 'Total Participants', value: `${lottery.participants.length}`, inline: true }
                    )
                    .setTimestamp();

                // ‚úÖ Use lottery's own availableAnimals for final distribution
                const distribution = lottery.availableAnimals.map(animal => {
                    const count = lottery.participants.filter(p => p.animal === animal).length;
                    const isWinner = animal === lottery.winningAnimal;
                    return `${animal} ${isWinner ? 'üëë' : ''}: ${count} bet${count !== 1 ? 's' : ''}`;
                }).join('\n');

                resultEmbed.addFields({
                    name: 'üìä Final Betting Distribution',
                    value: distribution,
                    inline: false
                });

                await thread.send({ embeds: [resultEmbed] });

                setTimeout(async () => {
                    try {
                        await thread.setArchived(true);
                    } catch (error) {
                        console.error('Failed to archive thread:', error);
                    }
                }, 5000);
            }
        } catch (error) {
            console.error('Failed to send results to thread:', error);
        }
    }

    setTimeout(() => archiveLottery(lottery, client, null, lottery.winningAnimal), LOTTERY_ARCHIVAL_DELAY);

    await lotteryCooldownModel.findOneAndUpdate(
        { serverID: guild.id, type: 'animal' },
        { nextAvailableAt: Date.now() + ANIMAL_LOTTERY_COOLDOWN },
        { upsert: true }
    );

    setTimeout(async () => {
        try {
            await lotteryModel.findByIdAndDelete(lottery._id);
            console.log(`[Lottery] Deleted completed Animal Race lottery from database: ${lottery._id}`);
        } catch (error) {
            console.error('Failed to delete completed lottery:', error);
        }
    }, LOTTERY_ARCHIVAL_DELAY + (5 * 60 * 1000));

    setTimeout(async () => {
        await createAnimalLottery(client, guild.id);
    }, ANIMAL_LOTTERY_COOLDOWN);
}

function scheduleAnimalRaceEnd(lotteryId, endsAt, client) {
    const timeUntilEnd = endsAt - Date.now();

    if (timeUntilEnd <= 0) {
        return;
    }

    setTimeout(async () => {
        try {
            const lottery = await lotteryModel.findById(lotteryId);
            if (!lottery || lottery.status === 'ended') {
                return;
            }

            const guild = client.guilds.cache.get(lottery.serverID);
            if (!guild) {
                return;
            }

            await endAnimalLottery(lottery, client, guild);
        } catch (error) {
            console.error('Error ending animal lottery:', error);
        }
    }, timeUntilEnd);
}

async function endNumberLottery(lottery, client, guild, winnerId, winningNumber) {
    lottery.status = 'ended';
    lottery.winnerId = winnerId;
    lottery.endedAt = Date.now();
    await lottery.save();

    const winnerProfile = await dbUtils.ensureProfile(winnerId, guild.id);
    winnerProfile.balance += lottery.prizePool;
    await winnerProfile.save();

    try {
        const balanceChangeEvent = require('../events/balanceChange');
        const member = await guild.members.fetch(winnerId);
        balanceChangeEvent.execute(member);
    } catch (err) {
        console.error('Failed to trigger balance change event:', err);
    }

    const channel = guild.channels.cache.get(lottery.channelId);
    if (channel && lottery.messageId) {
        try {
            const message = await channel.messages.fetch(lottery.messageId);
            const embed = createLotteryEmbed(lottery, true);
            await message.edit({ embeds: [embed], components: [] });
        } catch (error) {
            console.error('Failed to update lottery message:', error);
        }
    }

    if (lottery.logThreadId) {
        try {
            const thread = await client.channels.fetch(lottery.logThreadId);
            if (thread) {
                const logEmbed = new EmbedBuilder()
                    .setTitle('üéâ Number Draw Lottery Winner!')
                    .setColor(0x2ECC71)
                    .addFields(
                        { name: 'Winner', value: `<@${winnerId}>`, inline: true },
                        { name: 'Winning Number', value: `${winningNumber}`, inline: true },
                        { name: 'Prize Won', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                        { name: 'Total Draws', value: `${lottery.usedNumbers.length}`, inline: true },
                        { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
                    )
                    .setTimestamp();

                await thread.send({
                    content: `<@${winnerId}> üéâ **CONGRATULATIONS! YOU WON!**`,
                    embeds: [logEmbed]
                });

                setTimeout(async () => {
                    try {
                        await thread.setArchived(true);
                    } catch (error) {
                        console.error('Failed to archive thread:', error);
                    }
                }, 5000);
            }
        } catch (error) {
            console.error('Failed to send winner message to thread:', error);
        }
    }

    setTimeout(() => archiveLottery(lottery, client, winnerId, winningNumber), LOTTERY_ARCHIVAL_DELAY);

    await lotteryCooldownModel.findOneAndUpdate(
        { serverID: guild.id, type: 'number' },
        { nextAvailableAt: Date.now() + NUMBER_LOTTERY_COOLDOWN },
        { upsert: true }
    );

    setTimeout(async () => {
        try {
            await lotteryModel.findByIdAndDelete(lottery._id);
            console.log(`[Lottery] Deleted completed Number Draw lottery from database: ${lottery._id}`);
        } catch (error) {
            console.error('Failed to delete completed lottery:', error);
        }
    }, LOTTERY_ARCHIVAL_DELAY + (5 * 60 * 1000));

    setTimeout(async () => {
        await createNumberLottery(client, guild.id);
    }, NUMBER_LOTTERY_COOLDOWN);
}

async function endRaffleLottery(lottery, client, guild) {
    if (lottery.participants.length === 0) {
        lottery.status = 'ended';
        lottery.endedAt = Date.now();
        await lottery.save();

        const channel = guild.channels.cache.get(lottery.channelId);
        if (channel && lottery.messageId) {
            try {
                const message = await channel.messages.fetch(lottery.messageId);
                const embed = new EmbedBuilder()
                    .setTitle('üéüÔ∏è Raffle Lottery Ended')
                    .setDescription('No participants. Lottery cancelled.')
                    .setColor(0x95A5A6)
                    .setTimestamp();
                await message.edit({ embeds: [embed], components: [] });
            } catch (error) {
                console.error('Failed to update lottery message:', error);
            }
        }

        if (lottery.logThreadId) {
            try {
                const thread = await client.channels.fetch(lottery.logThreadId);
                if (thread) {
                    const cancelEmbed = new EmbedBuilder()
                        .setTitle('‚ùå Raffle Cancelled')
                        .setDescription('No participants joined this raffle.')
                        .setColor(0x95A5A6)
                        .setTimestamp();

                    await thread.send({ embeds: [cancelEmbed] });

                    setTimeout(async () => {
                        try {
                            await thread.setArchived(true);
                        } catch (error) {
                            console.error('Failed to archive thread:', error);
                        }
                    }, 5000);
                }
            } catch (error) {
                console.error('Failed to send cancellation to thread:', error);
            }
        }

        setTimeout(() => archiveLottery(lottery, client, null, null), LOTTERY_ARCHIVAL_DELAY);

        await lotteryCooldownModel.findOneAndUpdate(
            { serverID: guild.id, type: 'raffle' },
            { nextAvailableAt: Date.now() + RAFFLE_LOTTERY_COOLDOWN },
            { upsert: true }
        );

        setTimeout(async () => {
            try {
                await lotteryModel.findByIdAndDelete(lottery._id);
                console.log(`[Lottery] Deleted cancelled Raffle lottery from database: ${lottery._id}`);
            } catch (error) {
                console.error('Failed to delete completed lottery:', error);
            }
        }, LOTTERY_ARCHIVAL_DELAY + (5 * 60 * 1000));

        setTimeout(async () => {
            await createRaffleLottery(client, guild.id);
        }, RAFFLE_LOTTERY_COOLDOWN);

        return;
    }

    const randomIndex = Math.floor(Math.random() * lottery.participants.length);
    const winner = lottery.participants[randomIndex];

    lottery.status = 'ended';
    lottery.winnerId = winner.userId;
    lottery.endedAt = Date.now();
    await lottery.save();

    const winnerProfile = await dbUtils.ensureProfile(winner.userId, guild.id);
    winnerProfile.balance += lottery.prizePool;
    await winnerProfile.save();

    try {
        const balanceChangeEvent = require('../events/balanceChange');
        const member = await guild.members.fetch(winner.userId);
        balanceChangeEvent.execute(member);
    } catch (err) {
        console.error('Failed to trigger balance change event:', err);
    }

    const channel = guild.channels.cache.get(lottery.channelId);
    if (channel && lottery.messageId) {
        try {
            const message = await channel.messages.fetch(lottery.messageId);
            const embed = createLotteryEmbed(lottery, true);
            await message.edit({ embeds: [embed], components: [] });
        } catch (error) {
            console.error('Failed to update lottery message:', error);
        }
    }

    if (lottery.logThreadId) {
        try {
            const thread = await client.channels.fetch(lottery.logThreadId);
            if (thread) {
                const logEmbed = new EmbedBuilder()
                    .setTitle('üéâ Raffle Lottery Winner!')
                    .setColor(0x2ECC71)
                    .addFields(
                        { name: 'Winner', value: `<@${winner.userId}>`, inline: true },
                        { name: 'Prize Won', value: `${lottery.prizePool.toLocaleString()} points`, inline: true },
                        { name: 'Total Participants', value: `${lottery.participants.length}`, inline: true },
                        { name: 'Lottery ID', value: `\`${lottery._id}\``, inline: false }
                    )
                    .setTimestamp();

                await thread.send({
                    content: `<@${winner.userId}> üéâ **CONGRATULATIONS! YOU WON THE RAFFLE!**`,
                    embeds: [logEmbed]
                });

                setTimeout(async () => {
                    try {
                        await thread.setArchived(true);
                    } catch (error) {
                        console.error('Failed to archive thread:', error);
                    }
                }, 5000);
            }
        } catch (error) {
            console.error('Failed to send winner message to thread:', error);
        }
    }

    setTimeout(() => archiveLottery(lottery, client, winner.userId, null), LOTTERY_ARCHIVAL_DELAY);

    await lotteryCooldownModel.findOneAndUpdate(
        { serverID: guild.id, type: 'raffle' },
        { nextAvailableAt: Date.now() + RAFFLE_LOTTERY_COOLDOWN },
        { upsert: true }
    );

    setTimeout(async () => {
        try {
            await lotteryModel.findByIdAndDelete(lottery._id);
            console.log(`[Lottery] Deleted completed Raffle lottery from database: ${lottery._id}`);
        } catch (error) {
            console.error('Failed to delete completed lottery:', error);
        }
    }, LOTTERY_ARCHIVAL_DELAY + (5 * 60 * 1000));

    setTimeout(async () => {
        await createRaffleLottery(client, guild.id);
    }, RAFFLE_LOTTERY_COOLDOWN);
}

function scheduleRaffleEnd(lotteryId, endsAt, client) {
    const timeUntilEnd = endsAt - Date.now();

    if (timeUntilEnd <= 0) {
        return;
    }

    setTimeout(async () => {
        try {
            const lottery = await lotteryModel.findById(lotteryId);
            if (!lottery || lottery.status === 'ended') {
                return;
            }

            const guild = client.guilds.cache.get(lottery.serverID);
            if (!guild) {
                return;
            }

            await endRaffleLottery(lottery, client, guild);
        } catch (error) {
            console.error('Error ending raffle lottery:', error);
        }
    }, timeUntilEnd);
}

module.exports = {
    createLotteryEmbed,
    createLotteryButtons,
    endNumberLottery,
    endRaffleLottery,
    endAnimalLottery,
    scheduleAnimalRaceEnd,
    scheduleRaffleEnd,
    createNumberLottery,
    createRaffleLottery,
    createAnimalLottery,
    archiveLottery,
    NUMBER_LOTTERY_COST,
    RAFFLE_LOTTERY_COST,
    ANIMAL_LOTTERY_COST,
    ANIMAL_LOTTERY_ANIMALS
};